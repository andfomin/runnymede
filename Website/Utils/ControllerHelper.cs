using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using Microsoft.AspNet.Identity;
using Newtonsoft.Json;
using System.IO;

namespace Runnymede.Website.Utils
{
    public static class ControllerHelper
    {
        private const string Base36Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; // Base36
        // Base32. Exclude 0, O, 1, I to avoid visual ambiguity. Use capital letters only to allow for case-insensitive search.
        private const string Base32Chars = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ";

        /// <summary>
        /// Geenrates a random number in which every digit is a random Base32 character.
        /// </summary>
        /// <param name="digits">The length of the number</param>
        /// <param name="randoms">A sequence generated by Random is determined by the seed. If we need not a trully random number, but a determined and repeatable one based on some contents, seed Random with the contents hash, i.e. new Random(hash), and pass it to the function</param>
        /// <returns></returns>
        public static string GetBase32Number(int digits, Random[] randoms = null)
        {
            /* Random() uses an int32 seed. There may be 2^32 unique sequenses produced, so we can expect a collision once a year :).
             * The range of 8-digit Base32 number is larger than the range of Int32. We use each Random to generate four Base32 digits.
            */
            if (randoms == null)
            {
                // Random() uses an int32 seed based on the curent value of timer ticks.
                randoms = new[] { new Random() };
            }

            var extraRandomsNeeded = (digits + 3) / 4 - randoms.Length;
            if (extraRandomsNeeded > 0)
            {
                // Ticks discretion is 100 nsec, so two Random() instances instantiated without a delay produce the same sequence. We cannot more use the parameterless Random().
                var extraRandoms = Enumerable
                             .Repeat(new Random(Guid.NewGuid().GetHashCode()), extraRandomsNeeded)
                             ;
                randoms = randoms.Concat(extraRandoms).ToArray();
            }

            return new string(
                         Enumerable
                         .Repeat(Base32Chars, digits)
                         .Select((s, i) => s[randoms[i / 4].Next(s.Length)])
                         .ToArray()
                         );
        }

        /// <summary>
        /// Ten Base36 characters. The first seven ones are sequential over time, resolution is 1/36 of second. The three last ones are random.
        /// </summary>
        /// <returns></returns>
        public static string GetTenDigitBase36Number()
        {
            int radix = Base36Chars.Length;
            char[] charArray = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' }; // The number is padded with zeros at the beginning.
            int index = 9;

            // The three last chars are random.
            int hash = Math.Abs(Guid.NewGuid().GetHashCode());

            while (index > 6)
            {
                int remainder = (int)(hash % radix);
                charArray[index--] = Base36Chars[remainder];
                hash = hash / radix;
            }

            DateTime now = DateTime.UtcNow;

            // The seventh digit is the projection of milliseconds.
            int digit = now.Millisecond * (radix - 1) / 999;
            charArray[index--] = Base36Chars[digit];

            // The six first chars are seconds since the origin.	
            DateTime origin = new DateTime(2013, 12, 01, 16, 20, 00, DateTimeKind.Utc); // Arbitrary origin. The same as in the SQL code.
            TimeSpan diff = now - origin;
            int seconds = Convert.ToInt32(diff.TotalSeconds); // Positive int is enough for 67 years. 36^6 is bigger.

            while (seconds != 0)
            {
                int remainder = (int)(seconds % radix);
                charArray[index--] = Base36Chars[remainder];
                seconds = seconds / radix;
            }

            return new String(charArray);
        }

        /// <summary>
        /// Tvelve Base32 characters. The first eight ones are sequential over time, resolution upto millisecond. The four last ones are random.
        /// </summary>
        /// <returns></returns>
        public static string GetTvelveDigitBase32Number()
        {
            int radix = Base32Chars.Length;
            char[] charArray = { '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2' }; // Number is padded with zeros (wich are "2" in our case) at the beginning.
            int index = 11;

            // The four last chars are random.
            int hash = Math.Abs(Guid.NewGuid().GetHashCode());

            while (index > 7)
            {
                int remainder = (int)(hash % radix);
                charArray[index--] = Base32Chars[remainder];
                hash = hash / radix;
            }

            DateTime now = DateTime.UtcNow;

            // The eight first chars are milliseconds since the origin.	Should be enough for 34 years.
            DateTime origin = new DateTime(2013, 12, 01, 16, 20, 00, DateTimeKind.Utc); // Arbitrary origin. 
            TimeSpan diff = now - origin;
            long milliseconds = Convert.ToInt64(diff.TotalMilliseconds);

            while (milliseconds != 0)
            {
                int remainder = (int)(milliseconds % radix);
                charArray[index--] = Base32Chars[remainder];
                milliseconds = milliseconds / radix;
            }

            return new String(charArray);
        }

        public static int GetUserId(this Controller controller)
        {
            return IdentityHelper.GetUserId(controller.User.Identity);
        }

        public static string GetUserDisplayName(this Controller controller)
        {
            return IdentityHelper.GetUserDisplayName(controller.User.Identity);
        }

        public static bool GetUserIsTeacher(this Controller controller)
        {
            return IdentityHelper.GetUserIsTeacher(controller.User.Identity);
        }

        public static string SerializeAsJson(object value)
        {
            var settings = new JsonSerializerSettings
            {
                ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver(),
                NullValueHandling = NullValueHandling.Ignore,
                DefaultValueHandling = DefaultValueHandling.Ignore,
            };

            ////var serializer = JsonSerializer.Create(settings);
            ////using (var writer = new StringWriter())
            ////{
            ////    serializer.Serialize(writer, value);
            ////    return writer.ToString();
            ////};

            return JsonConvert.SerializeObject(value, settings);
        }

        public static Guid GetKeeper(this Controller controller)
        {
            var requestCookies = controller.Request.Cookies;
            var responseCookies = controller.Response.Cookies;
            var cookies = requestCookies.AllKeys.Contains(LoggingUtils.KeeperCookieName) 
                ? requestCookies 
                : (
                    responseCookies.AllKeys.Contains(LoggingUtils.KeeperCookieName) 
                    ? responseCookies 
                    : null
                );
            //Not Guid.TryParseExact(keeperCookieValue, "N", out keeper); If input is null, it does not throw an exception, but outputs Guid.Empty.
            return cookies != null ? new Guid(cookies[LoggingUtils.KeeperCookieName].Value) : Guid.Empty;
        }



    }
}
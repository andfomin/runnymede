using Microsoft.WindowsAzure.Storage.Table;
using Runnymede.Website.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using Newtonsoft.Json;

namespace Runnymede.Website.Utils
{
    public static class LoggingUtils
    {
        public enum Kind
        {
            Referer,
            Signup,
            Login
        }

        public const string AmbiguousTimezoneOffset = "Timezone offset is ambiguous.";
        private static long SequenceCounter = 0;
        private const string Base36Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; // Base36        
        private const string Base32Chars = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ"; // Base32. Exclude 0, O, 1, I to avoid visual ambiguity. Use capital letters only to allow for case-insensitive search.

        #region Id generation utils

        public static string GetUniquifiedObservedTime()
        {
            Interlocked.Increment(ref SequenceCounter);
            var now = DateTime.UtcNow;
            return now.ToString("u") + now.Millisecond.ToString("D3") + (SequenceCounter % 100000).ToString("D5"); // If required, the number is pre-padded with zeros.        
        }

        public static string GetUniqueObservedTime()
        {
            return DateTime.UtcNow.ToString("u") + " " + Guid.NewGuid().ToString("N").ToUpper();
        }

        /// <summary>
        /// Geenrates a random number in which every digit is a random Base32 character.
        /// </summary>
        /// <param name="digits">The length of the number</param>
        /// <param name="randoms">A sequence generated by Random is determined by the seed. If we need not a trully random number, but a determined and repeatable one based on some contents, seed Random with the contents hash, i.e. new Random(hash), and pass it to the function</param>
        /// <returns></returns>
        public static string GetBase32Number(int digits, Random[] randoms = null)
        {
            /* Random() uses an int32 seed. There may be 2^32 unique sequenses produced, so we can expect a collision once a year :).
             * The range of 8-digit Base32 number is larger than the range of Int32. We use each Random to generate four Base32 digits.
            */
            if (randoms == null)
            {
                // Random() uses an int32 seed based on the curent value of timer ticks.
                randoms = new[] { new Random() };
            }

            var extraRandomsNeeded = (digits + 3) / 4 - randoms.Length;
            if (extraRandomsNeeded > 0)
            {
                // Ticks discretion is 100 nsec, so two Random() instances instantiated without a delay produce the same sequence. We cannot more use the parameterless Random().
                var extraRandoms = Enumerable
                             .Repeat(new Random(Guid.NewGuid().GetHashCode()), extraRandomsNeeded)
                             ;
                randoms = randoms.Concat(extraRandoms).ToArray();
            }

            return new string(
                         Enumerable
                         .Repeat(Base32Chars, digits)
                         .Select((s, i) => s[randoms[i / 4].Next(s.Length)])
                         .ToArray()
                         );
        }

        /// <summary>
        /// Ten Base36 characters. The first seven ones are sequential over time, resolution is 1/36 of second. The three last ones are random.
        /// </summary>
        /// <returns></returns>
        public static string GetTenDigitBase36Number()
        {
            int radix = Base36Chars.Length;
            char[] charArray = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' }; // The number is padded with zeros at the beginning.
            int index = 9;

            // The three last chars are random.
            int hash = Math.Abs(Guid.NewGuid().GetHashCode());

            while (index > 6)
            {
                int remainder = (int)(hash % radix);
                charArray[index--] = Base36Chars[remainder];
                hash = hash / radix;
            }

            DateTime now = DateTime.UtcNow;

            // The seventh digit is the projection of milliseconds.
            int digit = now.Millisecond * (radix - 1) / 999;
            charArray[index--] = Base36Chars[digit];

            // The six first chars are seconds since the origin.	
            DateTime origin = new DateTime(2013, 12, 01, 16, 20, 00, DateTimeKind.Utc); // Arbitrary origin. The same as in the SQL code.
            TimeSpan diff = now - origin;
            int seconds = Convert.ToInt32(diff.TotalSeconds); // Positive int is enough for 67 years. 36^6 is bigger.

            while (seconds != 0)
            {
                int remainder = (int)(seconds % radix);
                charArray[index--] = Base36Chars[remainder];
                seconds = seconds / radix;
            }

            return new String(charArray);
        }

        /// <summary>
        /// Tvelve Base32 characters. The first eight ones are sequential over time, resolution upto millisecond. The four last ones are random.
        /// </summary>
        /// <returns></returns>
        public static string GetTvelveDigitBase32Number()
        {
            int radix = Base32Chars.Length;
            char[] charArray = { '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2' }; // Number is padded with zeros (wich are "2" in our case) at the beginning.
            int index = 11;

            // The four last chars are random.
            int hash = Math.Abs(Guid.NewGuid().GetHashCode());

            while (index > 7)
            {
                int remainder = (int)(hash % radix);
                charArray[index--] = Base32Chars[remainder];
                hash = hash / radix;
            }

            DateTime now = DateTime.UtcNow;

            // The eight first chars are milliseconds since the origin.	Should be enough for 34 years.
            DateTime origin = new DateTime(2013, 12, 01, 16, 20, 00, DateTimeKind.Utc); // Arbitrary origin. 
            TimeSpan diff = now - origin;
            long milliseconds = Convert.ToInt64(diff.TotalMilliseconds);

            while (milliseconds != 0)
            {
                int remainder = (int)(milliseconds % radix);
                charArray[index--] = Base32Chars[remainder];
                milliseconds = milliseconds / radix;
            }

            return new String(charArray);
        }

        #endregion

        private static ITableEntity CreateKeeperLogEntity(string logData)
        {
            //Interlocked.Increment(ref SequenceCounter);
            var now = DateTime.UtcNow;
            var entity = new KeeperLogEntity
            {
                PartitionKey = now.ToString("u"), // yyyy-MM-dd HH:mm:ssZ
                RowKey = Guid.NewGuid().ToString("N").ToUpper(),
                //RowKey =  now.Millisecond.ToString("D3") + (SequenceCounter % 100000).ToString("D5"), // If required, the number is pre-padded with zeros.
                LogData = logData,
            };
            return entity;
        }

        public static async Task WriteKeeperLogAsync(string logData)
        {
            await AzureStorageUtils.InsertEntryAsync(AzureStorageUtils.TableNames.KeeperLog, CreateKeeperLogEntity(logData));
        }

        public static int? CalculateTimeOffsetSec(string localTime)
        {
            if (!string.IsNullOrWhiteSpace(localTime))
            {
                // We get the localTime value from the wild web. Be cautious.
                try
                {
                    var parts = localTime.Split('/');
                    int dummy;
                    if (parts.Count() == 6 && parts.All(i => Int32.TryParse(i, out dummy)))
                    {
                        var arr = parts.Select(i => Convert.ToInt32(i)).ToArray();
                        var clientTime = new DateTime(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], DateTimeKind.Utc);
                        var span = clientTime - DateTime.UtcNow;
                        var timeOffsetSec = Convert.ToInt32(span.TotalSeconds);
                        return timeOffsetSec;
                    }
                }
                catch
                {
                }
            }

            return null;
        }


        //public static int? CalculateTimeOffsetSec(string localTime)
        //{
        //    if (!string.IsNullOrWhiteSpace(localTime))
        //    {
        //        // We get the localTime value from the wild web. Be cautious.
        //        try
        //        {
        //            var parts = localTime.Split('/');
        //            int dummy;
        //            if (parts.Count() == 6 && parts.All(i => Int32.TryParse(i, out dummy)))
        //            {
        //                var arr = parts.Select(i => Convert.ToInt32(i)).ToArray();
        //                var clientTime = new DateTime(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], DateTimeKind.Utc);
        //                var span = clientTime - DateTime.UtcNow;
        //                var timeOffsetSec = Convert.ToInt32(span.TotalSeconds);
        //                return timeOffsetSec;
        //            }
        //        }
        //        catch
        //        {
        //        }
        //    }

        //    return null;
        //}




        /// <summary>
        /// Infers the user's timezone offset based on the time reported by the browser.
        /// </summary>
        /// <param name="localTime"></param>
        /// <param name="reportedTimezoneOffsetMin"></param>
        /// <returns></returns>
        public static int? InferTimeOffsetMin(string localTime, int? reportedTimezoneOffsetMin)
        {
            int? inferredOffsetMin = reportedTimezoneOffsetMin;

            var calculatedTimeOffsetSec = CalculateTimeOffsetSec(localTime);

            if (calculatedTimeOffsetSec.HasValue)
            {
                var fractualQuartersOfHour = (calculatedTimeOffsetSec.Value / 60.0 / 15.0);
                var roundedQuartersOfHour = Convert.ToInt32(Math.Round(fractualQuartersOfHour));
                inferredOffsetMin = (roundedQuartersOfHour * 15);
            }

            return inferredOffsetMin % (60 * 24); // Some clients have set a wrong date.

            /* The outgoing offset has the sign which is opposite to the sign of the incoming offset. 
             * It is reported by JavaScript that way. It is discussed at +http://stackoverflow.com/a/21105733
             * Quote: Perhaps it's because when you see an offset in an ISO 8601 or RFC 822 string, that offset has already been applied. But when you call getTimezoneOffset() it's the offset to apply to bring it back to UTC.
             */
            /* Wikipedia  +http://en.wikipedia.org/wiki/Time_offset
             * The UTC offset is the difference in hours and minutes from UTC for a particular place and date. 
             */
            /* The JavaScript spec +http://ecma262-5.com/ELS5_HTML.htm#Section_15.9.5.26 
             * Date.prototype.getTimezoneOffset(). Returns the difference between local time and UTC time in minutes.
             */
            /* MDN +https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
             * The time-zone offset is the difference, in minutes, between UTC and local time.
             */
        }

        public static bool ClientTimeIsOk(string localTime, int? localTimezoneOffset)
        {
            var inferredTimeOffsetMin = InferTimeOffsetMin(localTime, localTimezoneOffset);
            // The inferred offset has the sign which is opposite to the sign of the incoming offset. See the comments in LoggingUtils.InferTimeOffsetMin()
            return (localTimezoneOffset + inferredTimeOffsetMin == 0);
        }

        public static string SerializeAsJson(object value)
        {
            var settings = new JsonSerializerSettings
            {
                ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver(),
                NullValueHandling = NullValueHandling.Ignore,
                DefaultValueHandling = DefaultValueHandling.Ignore,
            };

            ////var serializer = JsonSerializer.Create(settings);
            ////using (var writer = new StringWriter())
            ////{
            ////    serializer.Serialize(writer, value);
            ////    return writer.ToString();
            ////};

            return JsonConvert.SerializeObject(value, settings);
        }

    }
}